export default webf;
declare const webf: {
    eventDispatcher: {
        "__#1@#listeners": {};
        addListener(eventsName: any, callback: any, context: any, ...args: any[]): /*elided*/ any;
        addListenerOnce(eventsName: any, callback: any, context: any, ...listenerArgs: any[]): /*elided*/ any;
        dispatch(eventsName: any, ...args: any[]): /*elided*/ any;
        hasListener(eventName: any, callback: any, context: any): boolean;
        removeListener(eventName: any, callback: any, context: any): /*elided*/ any;
        getListeners(eventName: any): any;
        reset(): void;
    };
    translate: (lang: any, ns: any, label: any) => any;
    _: (lang: any, ns: any, label: any) => any;
    getLang: () => any;
    setLang: (lang: any) => void;
    equals: (o1: any, o2: any, seen?: WeakMap<WeakKey, any>) => any;
    noop: () => void;
    sizeOf: (o: any) => number;
    flatten: (o: Object | any[]) => any[];
    strParseFloat: (val: any) => number;
    throttle: (func: any, wait: any, leading?: boolean, trailing?: boolean, context?: null) => (...args: any[]) => void;
    debounce: (func: Function, wait: number, immediate?: boolean, context?: Object) => Function;
    round: (val: any, precision?: number) => number;
    floorTo: (n: any, precision: any) => number;
    plancher: (n: any, precision: any) => number;
    min: (list: any, cmp_func: any) => number | undefined;
    max: (list: any, cmp_func: any) => number | undefined;
    dec2hex: (n: number) => string;
    hex2dec: (hex: string) => number;
    dom: {
        children(el: Element, selector?: string): NodeList;
        child(el: Element, selector?: string): Element | null;
        findOne(refEl: Element | Document, selector?: string | Element | NodeList | Array<Element>): Element | null;
        find(refEl: Element | Document, selector: string | Element | NodeList | Array<Element>): Array<Element>;
        findOneByData(el: Element, data: string, value: string): Element | null;
        findByData(el: Element, data: string, value: string): Element[];
        addClass(el: Element | NodeList | Array<Element>, className: string): Element | NodeList | Array<Element>;
        removeClass(el: Element | NodeList | Array<Element>, className: string): Element | NodeList | Array<Element>;
        toggleClass(el: Element, classNames: string, force?: boolean): Element;
        hasClass(el: Element, classNames: string): boolean;
        append(node: Node, ...children: (Node | string)[]): Node;
        prepend(node: Node, ...children: (Node | string)[]): Node;
        remove(...els: Element | NodeList | Array<Element> | string): void;
        closest(el: Element, selector: string | Element): Element | null;
        next(el: Element, selector?: string): Element | null;
        prev(el: Element, selector?: string | null): Element | null;
        nextAll(el: Element, selector?: string): Element[];
        prevAll(el: Element, selector?: string): Element[];
        nextUntil(el: Element, selector: Element | string): Element[];
        prevUntil(el: Element, selector: Element | string): Element[];
        wrap(el: Element, wrappingElement: Element): Element;
        attr(el: Element, name: string, value?: any): Element | any;
        prop(el: Element, name: string, value?: any): any | Element;
        html(el: Element, html?: string): Element | any;
        text(el: Element, text?: string): Element | any;
        hide(el: Element): Element;
        show(el: Element): Element;
        toggle(el: Element): Element;
        data(el: Element, name: {
            [x: string]: string;
        } | string, value?: string): Element | DOMStringMap;
        removeData(el: Element, name: string): Element | any;
        on(el: Element | Document | Window, events: string, selector: string | Element | Function, handler?: Function | AddEventListenerOptions | boolean, options?: AddEventListenerOptions | boolean): Element;
        off(el: Element | Document | Window, events: string, selector: string | Element | Function, handler?: Function | AddEventListenerOptions | boolean, options?: AddEventListenerOptions | boolean): Element;
        css(el: HTMLElement, style: {
            [x: string]: string;
        } | string, value?: string): Element;
        closestFind(el: Element, selectorClosest: string, selectorFind: string): NodeList | null;
        closestFindOne(el: Element, selectorClosest: string, selectorFindOne: string): Element | null;
        first(nodeList: NodeList | Element | Array<Element>): Element | null;
        last(nodeList: NodeList | Array<Element>): Element | null;
        create(html: string): Element | null;
        eq(nodeList: NodeList | Array<Element>, index?: number): Element | null;
        after(el: Element, newEl: Element | string): Element | null;
        before(el: Element, newEl: Element | string): Element | null;
        empty(el: Element): Element;
        not(el: Element | NodeList, selector: string | Element): Element[];
        collide(elem1: Element, elem2: Element): boolean;
        matches(el: Element, selector: string | Element): boolean;
        replaceChild(el: Element, child: Element, oldChild: Element): Element;
        replaceChildren(el: Element, ...children: Element[]): Element;
        offset(el: Element | Document | Window): {
            top: number;
            left: number;
        };
    };
    isWindow: (o: any) => boolean;
    isDocument: (o: any) => boolean;
    isDomElement: (o: any) => boolean;
    getStyle: (el: Element, cssRule: string) => string;
    isString: (str: any) => boolean;
    isObject: (o: any) => boolean;
    isFunction: (f: any) => boolean;
    isPlainObject: (o: any) => boolean;
    isBoolean: (b: any) => boolean;
    isBool: (b: any) => boolean;
    isUndefined: (v: any) => v is undefined;
    isArrayLike: (o: any) => boolean;
    isArray: (a: any) => a is any[];
    isDate: (o: any) => boolean;
    isEvent: (o: any) => boolean;
    isInteger: (n: any) => boolean;
    isInt: (n: any) => boolean;
    isFloat: (n: any) => boolean;
    isScalar: (value: any) => boolean;
    isEventSupported: (eventName: any) => boolean;
    isTouchDevice: () => boolean;
    each: <T>(o: Collection<T>, callback: (key: number | string, value: T, o: Collection<T>, index: number) => (void | boolean), context?: any) => typeof o;
    foreach: <T>(o: Collection<T>, callback: (value: T, key: number | string, o: Collection<T>, index: number) => (void | boolean), context?: any) => typeof o;
    map: <T, R>(o: Collection<T>, callback: (key: number | string, value: T, o: Collection<T>, index: number) => (R | null | false), context?: any) => Array<R>;
    reduce: <T, R>(o: Collection<T>, callback: (accumulator: R | T, value: T, key: any, index: number, o: Collection<T>) => R, initialValue?: R) => R;
    extend: <T>(...args: (boolean | T)[]) => T;
    clone: <T>(o: T) => T;
    merge: <T>(first: Collection<T>, second?: Collection<T>, ...args: Collection<T>[]) => Array<T>;
    inArray: (value: any, arr: Object | any[], index?: number, strict?: boolean) => boolean;
    indexOf: (arr: any, elt: any, from?: number) => number;
    compareArray: (a1: any, a2: any) => any;
    arrayUnique: (arr: any) => any;
    array_unique: (arr: any) => any;
    arrayDiff: (array1: any, array2: any, strict?: boolean) => any;
    array_diff: (arr: any) => any;
    range: (size: any, startAt?: number, step?: number) => any[];
    trim: (str: any, char?: string) => any;
    ltrim: (str: any, char?: string) => any;
    rtrim: (str: any, char?: string) => any;
    stripMultipleSpaces: (str: any) => any;
    noAccent: (str: any) => any;
    br2nl: (str: any) => any;
    nl2br: (str: any) => any;
    ucfirst: (str: any) => any;
    lcfirst: (str: any) => any;
    insertTag: (str: any, tag: any, position?: number, length?: number) => string;
    substringIndex: (str: any, delimiter: any, index: any) => string;
    insert: (str: any, ins: any, n: any) => any;
    reverse: (str: any) => string;
    thousandSeparator: (value: any, separator?: string, pointDecimal?: string) => any;
    numberFormat: (number: any, decimals?: number, forceCentimes?: boolean, thousandSep?: string, pointDecimal?: string) => any;
    toPrice: (number: any, decimals?: number, forceCentimes?: boolean, thousandSep?: string, pointDecimal?: string) => any;
    pad: (str: string, pad_length: number, pad_str?: string, pad_type?: string) => string;
    rgb2hex: (r: number | number[], g?: number, b?: number) => string;
    rgbtohex: (r: number | number[], g?: number, b?: number) => string;
    hex2rgb: (hex: string) => number[];
    hextorgb: (hex: string) => number[];
    parse_url: (str: string) => Object;
    addUrlParam: (url: string, param: string | Object, value?: string | null) => string;
    decodeHtml: (str: any) => any;
    htmlquotes: (str: any) => any;
    htmlsimplequotes: (str: any) => any;
    repeat: (str: any, n: any) => string;
    stripTags: (str: any, tag: any) => any;
    toUrl: (str: any) => any;
    escapeRegex: (str: any) => any;
    camelCase: (str: any) => string;
    format: (str: any, ...args: any[]) => any;
    f: (str: any, ...args: any[]) => any;
    toCssClassName: (str: any) => any;
    hilite: (str: any, req: any, tag?: string) => any;
    formatSize: (bytes: any, decimalPoint?: string) => string;
    compareMixAlphaDigits: (a: any, b: any) => number;
};
import * as stringFunctions from './string.js';
import * as arrayFunctions from './array.js';
import * as traversal from './traversal.js';
import * as is from './is.js';
import { getStyle } from './dom.js';
import dom from './dom.js';
import * as math from './math.js';
import * as utils from './utils.js';
import eventDispatcher from './eventDispatcher.js';
export { stringFunctions, arrayFunctions, traversal, is, getStyle, dom, math, utils, eventDispatcher };
